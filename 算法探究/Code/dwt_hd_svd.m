%% This function applies DWT-HD-SVD watermarking method

function [watermarked_image, extracted_watermark] = dwt_hd_svd(cover_image,watermark_logo,alpha,attack,param)

%% Watermark embedding
% Calculate decomposition level
M = length(cover_image);
N = length(watermark_logo);
R = log2(M/N);

% 1. Apply R-level Haar wavelet and decompose image into sub-bands
% 2. Apply Hessenberg matrix
if R == 1
    % Apply 1-level Haar wavelet
    [LL, HL, LH, HH] = dwt2(cover_image, 'haar');
    % Apply Hessenberg matrix
    [P, H] = hess(LL);
elseif R==2
    % Apply 1-level Haar wavelet
    [LL, HL, LH, HH] = dwt2(cover_image, 'haar');
    % Apply 2-level Haar wavelet on LL sub-band (Lowest Frequency)
    [LL2, HL2, LH2, HH2] = dwt2(LL, 'haar');
    % HD is performed on LL2, and it is shown as
    [P, H] = hess(LL2);
elseif R==3
    % Apply 1-level Haar wavelet
    [LL, HL, LH, HH] = dwt2(cover_image, 'haar');
    % Apply 2-level Haar wavelet on LL sub-band (Lowest Frequency)
    [LL2, HL2, LH2, HH2] = dwt2(LL, 'haar');
    % Apply 3-level Haar wavelet on LL sub-band (Lowest Frequency)
    [LL3, HL3, LH3, HH3] = dwt2(LL2, 'haar');
    % HD is performed on LL3, and it is shown as
    [P, H] = hess(LL3);
end

% 3. Apply SVD to H matrix
[HUw, HSw, HVw] = svd(H, 'econ');

% 4. Apply SVD to watermark logo (W)
[Uw, Sw, Vw] = svd(double(watermark_logo), 'econ');

% 5. Compute an embedded singular value HSw_hat by adding HSw and Sw 
%    with a scaling factor alpha:
HSw_hat = HSw + alpha.*Sw;

% 6. The watermarked sub-band H_hat is generated by using the inverse SVD
H_hat = HUw * HSw_hat * HVw';

% 7. A new low-frequency approximate sub-band LL? is reconstructed
%    based on the inverse HD which is given by
LL_hat = P*H_hat*P';

% 8. The watermarked image C is obtained by performing the inverse 1-level DWT.
if R == 1
    watermarked_image = idwt2(LL_hat, HL, LH, HH, 'haar');
elseif R==2
    LL_hat = idwt2(LL_hat, HL2, LH2, HH2, 'haar');
    watermarked_image = idwt2(LL_hat, HL, LH, HH, 'haar');
elseif R==3
    LL_hat2 = idwt2(LL_hat, HL3, LH3, HH3, 'haar');
    LL_hat = idwt2(LL_hat2, HL2, LH2, HH2, 'haar');
    watermarked_image = idwt2(LL_hat, HL, LH, HH, 'haar');
end
watermarked_image = uint8(watermarked_image);
%% Attacks
watermarked_image = Attacks(watermarked_image,attack,param);

%% Watermark Extraction

% 1. The watermarked host image C is decomposed into four sub-bands by
% R-level DWT, which include LLw, LHw, HLw, HHw
% 2. HD is performed on LLw by
if R == 1
    [LLw, HLw, LHw, HHw] = dwt2(watermarked_image, 'haar');
    Hw = hess(LLw);
elseif R == 2
    [LLw, HLw, LHw, HHw] = dwt2(watermarked_image, 'haar');
    [LLw2, HLw2, LHw2, HHw2] = dwt2(LLw, 'haar');
    Hw = hess(LLw2);
elseif R == 3
    [LLw, HLw, LHw, HHw] = dwt2(watermarked_image, 'haar');
    [LLw2, HLw2, LHw2, HHw2] = dwt2(LLw, 'haar');
    [LLw3, HLw3, LHw3, HHw3] = dwt2(LLw2, 'haar');
    Hw = hess(LLw3);
end

% 3. Apply SVD to Hw
[HUw_hat, HSbw_hat, HVw_hat] = svd(Hw);

% 4. The extracted singular value Sw_hat is gained by:
Sw_hat = (HSbw_hat - HSw)./alpha;

% 5. The extracted watermark w_hat is reconstructed by inverse SVD, which
%    is described by
w_hat = Uw*Sw_hat*Vw';

extracted_watermark =uint8(w_hat);
end
